#!/bin/bash

# Common functions used in firewall rules. You must source this from a script
# that has already setup nftables!

function change_feature() {
	FC=`cat $1`
	if [ "$FC" != "$2" ]; then
		if [ "$DRYRUN" -eq 0 ]; then
			echo $2 > $1
			subsubstatus "$1 changed from $FC to $2"
		else
			subsubstatus "Dryrun: $1 would change from $FC to $2"
		fi
	fi
}

# This function sets or clears a feature for an interface
#
# usage:
#  if_feature [-4|-6] featurename value
# eg:
#  if_feature ip_forwarding 1
#  if_feature -6 ip_forwarding 1
#  if_feature -4 ip_forwarding 1
function if_feature() {
	NO6=
	NO4=
	NOSHIFT=

	case $1 in
		-4)
			NO6=1
			;;
		-6)
			NO4=1
			;;
		*)
			NOSHIFT=1
	esac

	if [ -z "$NOSHIFT" ]; then
		shift
	fi

	if [ -z "${if}" ]; then
		if [ -z "$NO4" -a -e /proc/sys/net/ipv4/conf/all/$1 ]; then
			change_feature /proc/sys/net/ipv4/conf/all/$1 $2
		fi
		if [ -z "$NO6" -a -e /proc/sys/net/ipv6/conf/all/$1 ]; then
			change_feature /proc/sys/net/ipv6/conf/all/$1 $2
		fi

	else
		if [ -z "$NO4" -a -e /proc/sys/net/ipv4/conf/${if}/$1 ]; then
			change_feature /proc/sys/net/ipv4/conf/${if}/$1 $2
		fi
		if [ -z "$NO6" -a -e /proc/sys/net/ipv6/conf/${if}/$1 ]; then
			change_feature /proc/sys/net/ipv6/conf/${if}/$1 $2
		fi
	fi
}

function remap_inout () {
	outrule=""
	while [ -n "$1" ]; do
		case $1 in
			dport)
				new=sport
				;;
			sport)
				new=dport
				;;
			daddr)
				new=saddr
				;;
			saddr)
				new=daddr
				;;
			iif)
				new=oif
				;;
			oif)
				new=iif
				;;
			if)
				new=of
				;;
			of)
				new='if'
				;;
			iifname)
				new=oifname
				;;
			oifname)
				new=iifname
				;;
			iiftype)
				new=oiftype
				;;
			oiftype)
				new=iiftype
				;;
			iifgroup)
				new=oifgroup
				;;
			oifgroup)
				new=iifgroup
				;;
			*)
				new=$1
		esac
		if [ ! -z "${outrule}" ]; then
			outrule="$outrule $new"
		else
			outrule="$new"
		fi
		shift
	done
	rule=$outrule
}
function register {
	# Add to list of registered rulesets
	IMPORTED="${IMPORTED} ${RULESET}"
	HAS_REGISTERED=1
	unset LOCAL_CHAIN
	declare -A LOCAL_CHAIN
	OLD_CHAIN=$CHAIN
	CHAIN=local
}

function import {
	local i
	local matches=$1
	LANG=C	# needed to fix bash counting lower case letters in an [A-Z]
	case $2 in
		[a-z]*)
			# assume anything beginning with a lowercase is a builtin
			return 1
			;;
		[0-9]*)
			# assume anything beginning with a number is a builtin
			return 1
			;;
		"")
			return 1
			;;
	esac

	RULESET=${2,,}
	HAS_REGISTERED=0

	for i in ${IMPORTED}; do
		if [ "${RULESET}" == "$i" ]; then
			# If this ruleset has already been registered, we can just jump to it
			nft ${matches} jump ${RULESET}

			RULESET=""
			return 0
		fi
	done

	if [ -f "${CONFDIR}/ruleset.d/${RULESET}.rule" ]; then
		. ${CONFDIR}/ruleset.d/${RULESET}.rule
	elif [ -f "ruleset.d/${RULESET}.rule" ]; then
		. ruleset.d/${RULESET}.rule
	else
		echo "Unknown ruleset ${RULESET}, ${RULESET}.rule file not found in $(pwd)/ruleset.d/ or ${CONFDIR}/ruleset.d/"
		exit -1
	fi

	subsubstatus Loaded ${RULESET}
	if [ ${HAS_REGISTERED} -eq 1 ]; then
		echo "	  chain ${RULESET} {" >> $OF
		for i in "${LOCAL_CHAIN[@]}"; do
			echo "		  $i" >> $OF
		done
		echo "	  }" >> $OF
		CHAIN=$OLD_CHAIN

		# Add a jump rule to the new chain created for the registered ruleset
		nft ${matches} jump ${RULESET}
	fi

	RULESET=""
	return 0
}

function check_interface_file {
	local interface_name=$1
	if [ ! -f "${CONFDIR}/interfaces.d/${interface_name}.if" ]; then
		echo "Interface file ${CONFDIR}/interfaces.d/${interface_name}.if is missing"
		exit -1
	fi
}

function nft(){
	rule="$@"

	if [ -z "${rule}" ]; then
		return
	fi

	local matches=$(echo ${rule} | awk '{$NF=""; print $0}' | awk '{$1=$1};1')
	local verdict=$(echo ${rule} | awk '{print $NF}')

	# $action might actually point to a ruleset, try and import it
	if import "${matches}" "${verdict}"; then
		# If import was successful then we don't need to keep going
		return
	fi

	case $CHAIN in
		in)
			IN+=("$rule")
			;;
		out)
			OUT+=("$rule")
			;;
		inout)
			IN+=("$rule")
			remap_inout $rule
			OUT+=("$rule")
			;;
		forward-in)
			re="(.*)\<accept\>(.*)"
			# Replace a non terminator accept with return
			if [[ "$@" =~ $re ]]; then
				rule="${BASH_REMATCH[1]} return ${BASH_REMATCH[2]}"
			fi
			FWD_IN+=("$rule")
			;;
		forward-out)
			FWD_OUT+=("$rule")
			;;
		forward)
			OLD_RULE="$rule"
			re="(.*)\<accept\>(.*)"
			# Replace a non terminator accept with return
			if [[ "$@" =~ $re ]]; then
				rule="${BASH_REMATCH[1]} return ${BASH_REMATCH[2]}"
			fi
			FWD_IN+=("$rule")

			rule=$OLD_RULE
			remap_inout $rule
			FWD_OUT+=("$rule")
			;;
		prerouting)
			PRE_ROUTE+=("$rule")
			;;
		postrouting)
			POST_ROUTE+=("$rule")
			;;
		host)
			check_interface_file localhost
			IN+=("jump localhost_input")
			OUT+=("jump localhost_output")
			;;
		host-in)
			check_interface_file localhost
			IN+=("jump localhost_input")
			;;
		host-out)
			check_interface_file localhost
			OUT+=("jump localhost_output")
			;;
		local)
			LOCAL_CHAIN+=("$rule")
			;;
		*)
			echo "Error at ${BASH_SOURCE[1]}:${BASH_LINENO[1]} Unknown chain '$CHAIN'"
			exit -1
	esac
}

function policy(){
	if [[ " ${CHAINS[@]} " =~ " ${1} " ]]; then
		CHAIN=$1
		shift
	fi

	local rule="$@"

	nft $rule
}

function policy_log(){
	if [[ " ${CHAINS[@]} " =~ " ${1} " ]]; then
		CHAIN=$1
		shift
	fi

	local rule="$@"

	local terminal_statements=(
		"accept"
		"drop"
		"reject"
		"queue"
		"continue"
		"return"
		"jump"
		"goto"
		)

	local log_prefix=""
	if [ ! -z "${RULESET}" ]; then
		log_prefix+="${RULESET}"
	else
		log_prefix+="${if}_${CHAIN}"
	fi

	local rule_array=(${rule})

	# Walk rule in reverse word order, looking for a terminal statement,
	# if we find one, put our log rule before it
	local log_rule
	local terminal_found=0
	local rule_array_size=${#rule_array[@]}-1
	for (( i=${rule_array_size}; i>=0 ; i-- )); do
		for terminal_statement in ${terminal_statements[@]}; do
			if [ "${rule_array[i]}" == "${terminal_statement}" ]; then
				terminal_found=1
				local start_of_rule=("${rule_array[@]:0:$i}")
				local end_of_rule=("${rule_array[@]:$i}")
				log_rule=$(log "${log_prefix}/${terminal_statement}")
				rule="${start_of_rule[@]} ${log_rule} ${end_of_rule[@]}"
				break
			fi
		done
	done

	# If there's no terminal statement, just add the log statement to the end
	if [ "${terminal_found}" -eq 0 ]; then
		log_rule=$(log "${log_prefix}")
		rule="${rule} ${log_rule}"
	fi

	nft $rule
}

function log(){
	local prefix=$1

	case "${conf_logging}" in
		syslog)
			echo "log prefix \"FW/$prefix: \" flags all limit rate 5/second"
			;;
		nflog)
			echo "log prefix \"FW/$prefix\" group 0 limit rate 5/second"
			;;
		none)
			;;
		*)
			echo "Unknown option '${conf_logging}' for logging in bearwall.conf"
			exit -1
	esac
}

function load_interface_rules() {
	if=$1
	declare -a IN=()
	declare -a OUT
	declare -a FWD_IN
	declare -a FWD_OUT
	declare -a PRE_ROUTE
	declare -a POST_ROUTE

	# List of valid chains
	CHAINS=(
		"in"
		"out"
		"inout"
		"forward-in"
		"forward-out"
		"forward"
		"prerouting"
		"postrouting"
		"host"
		"host-in"
		"host-out"
		"local"
		)

	substatus $if

	IFACE_FOUND=0
	for i in $KERNEL_INTERFACES; do
		if [ "$if" == "$i" ]; then
			IFACE_FOUND=1
			break
		fi
	done
	if [ "$IFACE_FOUND" -eq 0 ]; then
		case "$conf_missing" in
			ifname)
				INTERFACES_IFNAME+=($if)
				VMAP_IFNAME=1
				;;
			lazy)
				subsubstatus "Interface '$if' is missing: using ifname due to lazy"
				INTERFACES_IFNAME+=($if)
				VMAP_IFNAME=1
				;;
			ignore)
				subsubstatus "Interface '$if' is missing: ignoring (nft tables is likely to error)"
				INTERFACES+=($if)
				VMAP_IIF=1
				;;
			error)
				subsubstatus "Interface '$if' is missing: stop on error requested"
				exit -1
				;;
			withhold)
				subsubstatus "Interface '$if' is missing: withheld"
				return
				;;
			*)
				echo "Unknown option '$conf_missing' for missing in bearwall2.conf"
				exit -1
		esac
	else
		if [ "$conf_missing" == "ifname" ]; then
			VMAP_IFNAME=1
			INTERFACES_IFNAME+=($if)
		else
			VMAP_IIF=1
			INTERFACES+=($if)
		fi
	fi

	check_interface_file ${if}
	. $CONFDIR/interfaces.d/${if}.if

	if [ ${#IN[@]} -gt 0 ]; then
		if [ "$if" != "localhost" ]; then
			HOOK_INPUT=1
			INPUT_IFACE+=($if)
		fi
		echo "  chain ${if}_input {" >> $OF
		for i in "${IN[@]}"; do
			echo "    $i" >> $OF
		done
		echo "  }" >> $OF
	fi
	if [ ${#OUT[@]} -gt 0 ]; then
		if [ "$if" != "localhost" ]; then
			HOOK_OUTPUT=1
			OUTPUT_IFACE+=($if)
		fi
		echo "  chain ${if}_output{" >> $OF
		for i in "${OUT[@]}"; do
			echo "    $i" >> $OF
		done
		echo "  }" >> $OF
	fi

	# Beyond here is only for real interfaces
	if [ "$if" = "localhost" ]; then
		return
	fi

	if [ ${#FWD_IN[@]} -gt 0 ]; then
		HOOK_FORWARD=1
		FORWARD_IN_IFACE+=($if)
		echo "  chain ${if}_fwd_in {" >> $OF
		for i in "${FWD_IN[@]}"; do
			echo "    $i" >> $OF
		done
		echo "  }" >> $OF
	fi
	if [ ${#FWD_OUT[@]} -gt 0 ]; then
		HOOK_FORWARD=1
		FORWARD_OUT_IFACE+=($if)
		echo "  chain ${if}_fwd_out {" >> $OF
		for i in "${FWD_OUT[@]}"; do
			echo "    $i" >> $OF
		done
		echo "  }" >> $OF
	fi
	if [ ${#PREROUTING[@]} -gt 0 ]; then
		HOOK_PREROUTING=1
		PREROUTING_IFACE+=($if)
		echo "  chain ${if}_prerouting {" >> $OF
		for i in "${PREROUTING[@]}"; do
			echo "    $i" >> $OF
		done
		echo "  }" >> $OF
	fi
	if [ ${#POSTROUTING[@]} -gt 0 ]; then
		HOOK_POSTROUTING=1
		POSTROUTING_IFACE+=($if)
		echo "  chain ${if}_postrouting {" >> $OF
		for i in "${POSTROUTING[@]}"; do
			echo "    $i" >> $OF
		done
		echo "  }" >> $OF
	fi

}
function build_vmap () {
	REG=$1
	shift
	CHAIN=$1
	shift
	HOOK=$1
	shift

	case $HOOK in
		input|prerouting)
			map_iif=iif
			map_ifname=iifname
			;;
		output|postrouting)
			map_iif=oif
			map_ifname=oifname
			;;
		*)
			echo "FATAL: HOOK unknown to build_vmap"
			exit -1
	esac

	if [ $REG -gt 0 ]; then
		echo "  chain $CHAIN {" >> $OF
		echo "    type filter hook $HOOK priority 0; policy drop;" >> $OF

		if [ "$VMAP_IIF" -eq 1 ]; then
			echo "    meta $map_iif vmap {" >> $OF
			for i in "$@"; do
				for j in "${INTERFACES[@]}"; do
					if [ "$j" == "$i" ]; then
						echo "      $i: jump ${i}_$CHAIN," >> $OF
						break
					fi
				done
			done
			echo "    }" >> $OF
		fi
		if [ "$VMAP_IFNAME" -eq 1 ]; then
			echo "    meta $map_ifname vmap {" >> $OF
			for i in "$@"; do
				for j in "${INTERFACES_IFNAME[@]}"; do
					if [ "$j" == "$i" ]; then
						echo "      \"$i\": jump ${i}_$CHAIN," >> $OF
						break
					fi
				done
			done
			echo "    }" >> $OF
		fi

		echo -n "	 " >> $OF
		log "FW/End of $CHAIN: " >> $OF
		echo "	}" >> $OF
	fi
}
function build_vmap_fwd () {
	if [ $HOOK_FORWARD -gt 0 ]; then
		echo "  chain forward {" >> $OF
		echo "    type filter hook forward priority 0; policy drop;" >> $OF
		if [ "$VMAP_IIF" -eq 1 ]; then
			echo "    meta iif vmap {" >> $OF
			for i in "${FORWARD_IN_IFACE[@]}"; do
				for j in "${INTERFACES[@]}"; do
					if [ "$j" == "$i" ]; then
						echo "      $i: jump ${i}_fwd_in," >> $OF
						break
					fi
				done
			done
			echo "    }" >> $OF
		fi
		if [ "$VMAP_IFNAME" -eq 1 ]; then
			echo "    meta iifname vmap {" >> $OF
			for i in "${FORWARD_IN_IFACE[@]}"; do
				for j in "${INTERFACES_IFNAME[@]}"; do
					if [ "$j" == "$i" ]; then
						echo "      $i: jump ${i}_fwd_in," >> $OF
						break
					fi
				done
			done
			echo "    }" >> $OF
		fi

		if [ "$VMAP_IIF" -eq 1 ]; then
			echo "    meta oif vmap {" >> $OF
			for i in "${FORWARD_OUT_IFACE[@]}"; do
				for j in "${INTERFACES[@]}"; do
					if [ "$j" == "$i" ]; then
						echo "      $i: jump ${i}_fwd_out," >> $OF
						break
					fi
				done
			done
			echo "    }" >> $OF
		fi
		if [ "$VMAP_IFNAME" -eq 1 ]; then
			echo "    meta oifname vmap {" >> $OF
			for i in "${FORWARD_OUT_IFACE[@]}"; do
				for j in "${INTERFACES_IFNAME[@]}"; do
					if [ "$j" == "$i" ]; then
						echo "      $i: jump ${i}_fwd_out," >> $OF
						break
					fi
				done
			done
			echo "    }" >> $OF
		fi

		echo -n "	 " >> $OF
		log "FW/End of forward: " >> $OF
		echo "	}" >> $OF
	fi
}
